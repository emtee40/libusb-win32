#include <usb.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>

#define TRANSFER_TIMEDOUT -116

/// <summary>
/// Custom vendor request implemented in the test firmware. 
/// </summary>
enum BENCHMARK_DEVICE_COMMANDS
{
    SET_TEST = 0x0E,
    GET_TEST = 0x0F,
};

enum BENCHMARK_DEVICE_TEST_TYPE
{
    TestTypeNone	= 0x00,
    TestTypeRead	= 0x01,
    TestTypeWrite	= 0x02,
    TestTypeLoop	= 0x03,
    TestTypeMask	= 0xff
};

struct BENCHMARK_TEST_PARAM
{
	// User configurable value set from the command line.
	//
	INT Vid;
	INT Pid;
	INT DeviceIndex;
	INT Intf;
	INT Ep;

	INT Refresh;
	INT Timeout;
	INT Retry;

	INT BufferSize;
	INT BufferCount;
	BOOL NoTestSelect;
	INT EndpointType;
	INT Priority;
	enum BENCHMARK_DEVICE_TEST_TYPE TestType;

	// Internal value use during the test.
	//
    usb_dev_handle* DeviceHandle;
	BOOL IsCancelled;
	BOOL IsUserAborted;
};

struct BENCHMARK_TRANSFER_PARAM
{
	struct BENCHMARK_TEST_PARAM* Test;
	
	HANDLE ThreadHandle;
	DWORD ThreadID;
    INT EndpointID;

	BOOL IsRunning;

	LONG TotalTransferred;
	LONG Packets;
	DWORD StartTick;
	DWORD LastTick;

	LONG TotalTimeoutCount;
	LONG RunningTimeoutCount;

	char Buffer[0];
};

// Benchmark device api.
usb_dev_handle*	Bench_Open(WORD vid, WORD pid, INT dev_index);
int Bench_SetTestType(struct usb_dev_handle* dev, enum BENCHMARK_DEVICE_TEST_TYPE testType, int intf);
int Bench_GetTestType(struct usb_dev_handle* dev, enum BENCHMARK_DEVICE_TEST_TYPE* testType, int intf);

// Critical section for update running status.
CRITICAL_SECTION DisplayCriticalSection;

// Internal function used by the benchmark application.
void ShowHelp(void);
void SetTestDefaults(struct BENCHMARK_TEST_PARAM* test);
char* GetParamStrValue(const char* src, const char* paramName);
BOOL GetParamIntValue(const char* src, const char* paramName, INT* returnValue);
int ValidateBenchmarkArgs(struct BENCHMARK_TEST_PARAM* testParams);
int ParseBenchmarkArgs(struct BENCHMARK_TEST_PARAM* testParams, int argc, char **argv);
void FreeTransferParam(struct BENCHMARK_TRANSFER_PARAM** testTransferRef);
struct BENCHMARK_TRANSFER_PARAM* CreateTransferParam(struct BENCHMARK_TEST_PARAM* test, int endpointID);
void GetBytesSec(struct BENCHMARK_TRANSFER_PARAM* transferParam, double* bps);
void ShowRunningStatus(struct BENCHMARK_TRANSFER_PARAM* transferParam);
void ShowDetailedStatus(struct BENCHMARK_TRANSFER_PARAM* transferParam);
void WaitForTestTransfer(struct BENCHMARK_TRANSFER_PARAM* transferParam);

// The thread transfer routine.
DWORD TransferThreadProc(struct BENCHMARK_TRANSFER_PARAM* transferParams);

#define TRANSFER_DISPLAY(TransferParam, ReadingString, WritingString) \
	((TransferParam->EndpointID & USB_ENDPOINT_DIR_MASK) ? ReadingString : WritingString)

const char* TestDisplayString[] = {"None", "Read", "Write", "Loop", NULL};
const char* EndpointTypeDisplayString[] = {"Control", "Isochronous", "Bulk", "Interrupt", NULL};

void SetTestDefaults(struct BENCHMARK_TEST_PARAM* test)
{
	memset(test,0,sizeof(struct BENCHMARK_TEST_PARAM));

	test->Ep			= 0x01;
	test->Vid			= 1234;
	test->Pid			= 5678;
	test->Refresh		= 1000;
	test->Timeout		= 5000;
	test->TestType		= TestTypeLoop;
	test->BufferSize	= 4096;
	test->BufferCount   = 1;
	test->EndpointType  = USB_ENDPOINT_TYPE_BULK;
	test->Priority		= THREAD_PRIORITY_NORMAL;
}

usb_dev_handle* Bench_Open(WORD vid, WORD pid, INT dev_index)
{
    struct usb_bus *bus;
    struct usb_device *dev;

    for (bus = usb_get_busses(); bus; bus = bus->next)
    {
        for (dev = bus->devices; dev; dev = dev->next)
        {
            if (dev->descriptor.idVendor == vid && dev->descriptor.idProduct == pid)
            {
				if (dev_index-- <= 0)
					return usb_open(dev);
            }
        }
    }
    return NULL;
}

int Bench_SetTestType(struct usb_dev_handle* dev, enum BENCHMARK_DEVICE_TEST_TYPE testType, int intf)
{
	char buffer[1];
	int ret = 0;

	ret = usb_control_msg(dev,
		USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN,
		SET_TEST, testType, intf,
		buffer, 1,
		1000);


	return ret;
}

int Bench_GetTestType(struct usb_dev_handle* dev, enum BENCHMARK_DEVICE_TEST_TYPE* testType, int intf)
{
	char buffer[1];
	int ret = 0;

	ret = usb_control_msg(dev,
		USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_ENDPOINT_IN,
		GET_TEST, 0, intf,
		buffer, 1,
		1000);

	if (ret == 1)
		*testType = buffer[0];

	return ret;
}

DWORD TransferThreadProc(struct BENCHMARK_TRANSFER_PARAM* transferParam)
{
	int ret;
	const char* dispReadingWriting = TRANSFER_DISPLAY(transferParam,"reading","writing");

	transferParam->IsRunning = TRUE;
	while (!transferParam->Test->IsCancelled)
	{
		if (transferParam->EndpointID & USB_ENDPOINT_DIR_MASK)
			ret = usb_bulk_read(
				transferParam->Test->DeviceHandle, 
				transferParam->EndpointID,
				transferParam->Buffer,
				transferParam->Test->BufferSize,
				transferParam->Test->Timeout);
		else
			ret = usb_bulk_write(
				transferParam->Test->DeviceHandle, 
				transferParam->EndpointID,
				transferParam->Buffer,
				transferParam->Test->BufferSize,
				transferParam->Test->Timeout);

		if (ret < 0)
		{
			if (transferParam->Test->IsUserAborted) break;
			if (ret == TRANSFER_TIMEDOUT)
			{
				transferParam->TotalTimeoutCount++;
				transferParam->RunningTimeoutCount++;
				printf("Timeout #%d %s on Ep%02Xh..\n",
					transferParam->RunningTimeoutCount,
					dispReadingWriting, 
					transferParam->EndpointID);

				if (transferParam->RunningTimeoutCount > transferParam->Test->Retry)
					break;
			}
			else
			{
				printf("error %s!\n%s\n",dispReadingWriting, usb_strerror());
				break;
			}
		}
		else
		{
			transferParam->RunningTimeoutCount = 0;
		}

		EnterCriticalSection(&DisplayCriticalSection);

		if (!transferParam->StartTick && transferParam->Packets >= 0)
		{
			transferParam->StartTick = GetTickCount();
			transferParam->LastTick = transferParam->StartTick;
			transferParam->Packets = 0;
			transferParam->TotalTransferred = 0;
		}
		else
		{
			transferParam->LastTick = GetTickCount();
			transferParam->TotalTransferred+=ret;
			transferParam->Packets++;
		}

		LeaveCriticalSection(&DisplayCriticalSection);
	}
	transferParam->IsRunning = FALSE;

	return 1;
}

char* GetParamStrValue(const char* src, const char* paramName)
{
	char* startCh;
	if ((startCh = strstr(src,paramName)))
		return (char*)(startCh+strlen(paramName));

	return NULL;
}

BOOL GetParamIntValue(const char* src, const char* paramName, INT* returnValue)
{
	char* value = GetParamStrValue(src, paramName);
	if (value)
	{
		*returnValue = strtol(value, NULL, 0);
		return TRUE;
	}
	return FALSE;
}

int ValidateBenchmarkArgs(struct BENCHMARK_TEST_PARAM* testParams)
{
	if (testParams->BufferCount < 1 || testParams->BufferCount > 3)
	{
		printf("Invalid BufferCount argument! %d\n",testParams->BufferCount);
		printf("BufferCount must be 1, 2 or 3.\n");
		return -1;
	}
	return 0;
}

int ParseBenchmarkArgs(struct BENCHMARK_TEST_PARAM* testParams, int argc, char **argv)
{
	#define GET_INT_VAL 
	char arg[1024];
	char* value;
	int iarg;
	for (iarg=1; iarg < argc; iarg++)
	{
		strcpy(arg, argv[iarg]);
		strlwr(arg);

		if      (GetParamIntValue(arg, "vid=",			&testParams->Vid)){}
		else if (GetParamIntValue(arg, "pid=",			&testParams->Pid)){}
		else if (GetParamIntValue(arg, "retry=",		&testParams->Retry)){}
		else if (GetParamIntValue(arg, "buffercount=",	&testParams->BufferCount)){}
		else if (GetParamIntValue(arg, "buffersize=",	&testParams->BufferSize)){}
		else if (GetParamIntValue(arg, "timeout=",		&testParams->Timeout)){}
		else if (GetParamIntValue(arg, "intf=",			&testParams->Intf)){}
		else if (GetParamIntValue(arg, "ep=",			&testParams->Ep)){}
		else if (GetParamIntValue(arg, "refresh=",			&testParams->Refresh)){}
		else if ((value=GetParamStrValue(arg,"type=")))
		{
			if (GetParamStrValue(value,"bulk"))
			{
				testParams->EndpointType = USB_ENDPOINT_TYPE_BULK;
			}
			else if (GetParamStrValue(value,"int"))
			{
				testParams->EndpointType = USB_ENDPOINT_TYPE_INTERRUPT;
			}
			else if (GetParamStrValue(value,"iso"))
			{
				testParams->EndpointType = USB_ENDPOINT_TYPE_ISOCHRONOUS;
			}
			else
			{
				// Invalid EndpointType argument.
				printf("Invalid endpoint type argument! %s\n",argv[iarg]);
				return -1;

			}
		}
		else if ((value=GetParamStrValue(arg,"priority=")))
		{
			if (GetParamStrValue(value,"lowest"))
			{
				testParams->Priority=THREAD_PRIORITY_LOWEST;
			}
			else if (GetParamStrValue(value,"belownormal"))
			{
				testParams->Priority=THREAD_PRIORITY_BELOW_NORMAL;
			}
			else if (GetParamStrValue(value,"normal"))
			{
				testParams->Priority=THREAD_PRIORITY_NORMAL;
			}
			else if (GetParamStrValue(value,"abovenormal"))
			{
				testParams->Priority=THREAD_PRIORITY_ABOVE_NORMAL;
			}
			else if (GetParamStrValue(value,"highest"))
			{
				testParams->Priority=THREAD_PRIORITY_HIGHEST;
			}
			else
			{
				printf("Invalid priority argument! %s\n",argv[iarg]);
				return -1;
			}
		}
		else if (!stricmp(arg,"notestselect"))
		{
			testParams->NoTestSelect = TRUE;
		}
		else if (!stricmp(arg,"read"))
		{
			testParams->TestType = TestTypeRead;
		}
		else if (!stricmp(arg,"write"))
		{
			testParams->TestType = TestTypeWrite;
		}
		else if (!stricmp(arg,"loop"))
		{
			testParams->TestType = TestTypeLoop;
		}
		else
		{
			printf("Invalid argument! %s\n",argv[iarg]);
			return -1;
		}
	}
	return ValidateBenchmarkArgs(testParams);
}
void FreeTransferParam(struct BENCHMARK_TRANSFER_PARAM** testTransferRef)
{
	if (*testTransferRef)
	{
		if ((*testTransferRef)->ThreadHandle)
		{
			CloseHandle((*testTransferRef)->ThreadHandle);
			(*testTransferRef)->ThreadHandle = NULL;
		}
		free(*testTransferRef);
		*testTransferRef = NULL;
	}
}

struct BENCHMARK_TRANSFER_PARAM* CreateTransferParam(struct BENCHMARK_TEST_PARAM* test, int endpointID)
{
	struct BENCHMARK_TRANSFER_PARAM* transferParam;
	int allocSize = sizeof(struct BENCHMARK_TRANSFER_PARAM)+(test->BufferSize * test->BufferCount);

	transferParam = (struct BENCHMARK_TRANSFER_PARAM*) malloc(allocSize);
	
	if (transferParam)
	{
		memset(transferParam, 0, allocSize);
		transferParam->Test = test;
		transferParam->EndpointID = endpointID;

		transferParam->ThreadHandle = CreateThread(
			NULL,
			0,
			(LPTHREAD_START_ROUTINE)TransferThreadProc,
			transferParam,
			CREATE_SUSPENDED,
			&transferParam->ThreadID);

		if (!transferParam->ThreadHandle)
		{
			printf("Failed creating thread!\n");
			FreeTransferParam(&transferParam);
		}

	}

	if (!transferParam)
		printf("Failed creating transfer param!\n");

	return transferParam;
}

void GetBytesSec(struct BENCHMARK_TRANSFER_PARAM* transferParam, double* bps)
{
    double ticksSec;

	if ((!transferParam->StartTick) || (transferParam->StartTick >= transferParam->LastTick))
	{
		*bps=0;
	}
	else
	{
		ticksSec = (transferParam->LastTick - transferParam->StartTick);
		ticksSec /= 1000.0;

		*bps = transferParam->TotalTransferred;
		*bps /= ticksSec;
	}
}

void ShowRunningStatus(struct BENCHMARK_TRANSFER_PARAM* transferParam)
{
    double bps;

	if ((!transferParam->StartTick) || (transferParam->StartTick >= transferParam->LastTick))
	{
		printf("Synchronizing %d..\n", abs(transferParam->Packets));
	}
	else
	{
		GetBytesSec(transferParam,&bps);
		printf("bytes/sec: %.0f packets: %d\n", bps, transferParam->Packets);
	}

}

void ShowDetailedStatus(struct BENCHMARK_TRANSFER_PARAM* transferParam)
{
	double bps;

	if (!transferParam) return;

    printf("%s Test Information\n",TestDisplayString[transferParam->Test->TestType & 3]);
    printf("\tVid / Pid       : %04Xh / %04Xh\n", transferParam->Test->Vid,  transferParam->Test->Pid);
    printf("\tPriority        : %d\n", transferParam->Test->Priority);
    printf("\tBuffer Size     : %d\n", transferParam->Test->BufferSize);
 	printf("\tBuffer Count    : %d\n", transferParam->Test->BufferCount);
    printf("\tDisplay Refresh : %d (ms)\n", transferParam->Test->Refresh);
    printf("\tTransfer Timeout: %d (ms)\n", transferParam->Test->Timeout);
    printf("\tRetry Count     : %d\n", transferParam->Test->Retry);
	
	if (transferParam->Test->TestType & TestTypeRead)
		printf("\tRead Endpoint   : %02Xh\n", transferParam->Test->Ep | USB_ENDPOINT_DIR_MASK);
	
	if (transferParam->Test->TestType & TestTypeWrite)
		printf("\tWrite Endpoint  : %02Xh\n", transferParam->Test->Ep);
    
	printf("\tEndpoint Type   : %s\n", EndpointTypeDisplayString[transferParam->Test->EndpointType & 3]);
	printf("\tInterface #     : %02Xh\n", transferParam->Test->Intf);

	if (transferParam->StartTick && transferParam->TotalTransferred)
	{
		GetBytesSec(transferParam,&bps);
		printf("%s Transfer Information\n",TestDisplayString[transferParam->Test->TestType & 3]);
		printf("\tTransferred     : %d\n", transferParam->TotalTransferred);
		printf("\tPackets         : %d\n", transferParam->Packets);
		printf("\tTimeouts        : %d\n", transferParam->TotalTimeoutCount);
		printf("\tBytes/sec       : %.0f\n", bps);
	}
	printf("\n");
}

void WaitForTestTransfer(struct BENCHMARK_TRANSFER_PARAM* transferParam)
{
	DWORD exitCode;
	while(transferParam)
	{
		if (!transferParam->IsRunning)
		{
			if (GetExitCodeThread(transferParam->ThreadHandle, &exitCode))
			{
				if (exitCode == 1)
				{
					printf("Stopped Ep%02Xh thread.\tExitCode=%d\n", 
						transferParam->EndpointID, exitCode);
					break;
				}
			}
			else
			{
				printf("Failed getting Ep%02Xh thread exit code!\n",transferParam->EndpointID);
				break;
			}
		}
		Sleep(100);
		printf("Waiting for Ep%02Xh thread..\n", transferParam->EndpointID);
	}
}
void ResetRunningStatus(struct BENCHMARK_TRANSFER_PARAM* transferParam)
{
	if (!transferParam) return;

	transferParam->StartTick=0;
	transferParam->TotalTransferred=0;
	transferParam->Packets=0;
	transferParam->LastTick=0;
	transferParam->RunningTimeoutCount=0;
}

int main(int argc, char** argv)
{
	struct BENCHMARK_TEST_PARAM Test;
	struct BENCHMARK_TRANSFER_PARAM* ReadTest	= NULL;
	struct BENCHMARK_TRANSFER_PARAM* WriteTest	= NULL;
	int key;

	if (argc == 1)
	{
		ShowHelp();
		return -1;
	}
	SetTestDefaults(&Test);

	// Load the command line arguments.
	if (ParseBenchmarkArgs(&Test, argc, argv) < 0)
		return -1;

	// Initialize the critical section used for locking
	// the volatile members of the transfer params in order
	// to update/modify the running statistics.
	//
	InitializeCriticalSection(&DisplayCriticalSection);

	// Initialize the library.
    usb_init();

	// Find all busses.
    usb_find_busses();

	// Find all connected devices.
    usb_find_devices();

	// Open a benchmark device. see Bench_Open().
	Test.DeviceHandle = Bench_Open(Test.Vid, Test.Pid, Test.DeviceIndex);
	if (!Test.DeviceHandle)
	{
		printf("Device %04X:%04X not found!\n",Test.Vid, Test.Pid);
		goto Done;
	}

	// Set configuration #1.
    if (usb_set_configuration(Test.DeviceHandle, 1) < 0)
    {
		printf("Failed setting configuration #%d!\n%s\n",1,usb_strerror());
		goto Done;
    }

	// Claim_interface Test.Intf (Default is #0)
    if (usb_claim_interface(Test.DeviceHandle, Test.Intf) < 0)
    {
		printf("Failed claiming interface #%d!\n%s\n", Test.Intf, usb_strerror());
		goto Done;
    }

	// If "NoTestSelect" appears in the command line then don't send the control
	// messages for selecting the test type.
	//
	if (!Test.NoTestSelect)
	{
		if (Bench_SetTestType(Test.DeviceHandle, Test.TestType, Test.Intf) != 1)
		{
			printf("Failed setting bechmark test type #%d!\n%s\n", Test.TestType, usb_strerror());
			goto Done;
		}
	}

	printf("Benchmark device %04X:%04X opened..\n",Test.Vid, Test.Pid);

	// If reading from the device create the read transfer param. This will also create
	// a thread in a suspended state.
	//
	if (Test.TestType & TestTypeRead)
	{
		ReadTest = CreateTransferParam(&Test, Test.Ep | USB_ENDPOINT_DIR_MASK);
		if (!ReadTest) goto Done;
	}

	// If writing to the device create the write transfer param. This will also create
	// a thread in a suspended state.
	//
	if (Test.TestType & TestTypeWrite)
	{
		WriteTest = CreateTransferParam(&Test, Test.Ep);
		if (!WriteTest) goto Done;
	}

	if (ReadTest)
		ShowDetailedStatus(ReadTest);
	else
		ShowDetailedStatus(WriteTest);

	printf("Press 'Q' to exit, any other key to begin..");
	key = _getch();
	printf("\n");
	if (key=='Q' || key=='q') goto Done;

	// Set the thread priority and start it.
	if (ReadTest)
	{
		SetThreadPriority(ReadTest->ThreadHandle, Test.Priority);
		ResumeThread(ReadTest->ThreadHandle);
	}

	// Set the thread priority and start it.
	if (WriteTest)
	{
		SetThreadPriority(WriteTest->ThreadHandle, Test.Priority);
		ResumeThread(WriteTest->ThreadHandle);
	}

	while(!Test.IsCancelled)
	{
		Sleep(Test.Refresh);

		if (_kbhit())
		{
			// A key was pressed.
			key = _getch();
			switch(key)
			{
			case 'Q':
			case 'q':
				Test.IsUserAborted = TRUE;
				Test.IsCancelled = TRUE;
				break;
			case 'I':
			case 'i':
				// LOCK the display critical section
				EnterCriticalSection(&DisplayCriticalSection);
				
				// Print benchmark test details.
				if (ReadTest)
					ShowDetailedStatus(ReadTest);
				else
					ShowDetailedStatus(WriteTest);
				
				// UNLOCK the display critical section 
				LeaveCriticalSection(&DisplayCriticalSection);
				break;

			case 'R':
			case 'r':
				// LOCK the display critical section
				EnterCriticalSection(&DisplayCriticalSection);

				// Reset the running status.
				ResetRunningStatus(ReadTest);
				ResetRunningStatus(WriteTest);

				// UNLOCK the display critical section 
				LeaveCriticalSection(&DisplayCriticalSection);
				break;
			}

			// Only one key at a time.
			while (_kbhit()) _getch();
		}

		// If the read test should be running and it isn't, cancel the test.
		if ((ReadTest) && !ReadTest->IsRunning)
		{
			Test.IsCancelled = TRUE;
			break;
		}

		// If the write test should be running and it isn't, cancel the test.
		if ((WriteTest) && !WriteTest->IsRunning)
		{
			Test.IsCancelled = TRUE;
			break;
		}

		// LOCK the display critical section
		EnterCriticalSection(&DisplayCriticalSection);

		// Print benchmark stats
		if (ReadTest)
			ShowRunningStatus(ReadTest);
		else
			ShowRunningStatus(WriteTest);

		// UNLOCK the display critical section 
		LeaveCriticalSection(&DisplayCriticalSection);
	}

	// If the thread is still running, abort and reset the endpoint.
	if ((ReadTest) && ReadTest->IsRunning)
		usb_resetep(Test.DeviceHandle, ReadTest->EndpointID);
	
	// If the thread is still running, abort and reset the endpoint.
	if ((WriteTest) && WriteTest->IsRunning)
		usb_resetep(Test.DeviceHandle, WriteTest->EndpointID);

	// Small delay if usb_resetep() is called. This will usually ensure
	// that WaitForTestTransfer() returns immediately.
	Sleep(10);

	// Wait for transfer threads to exit.
	WaitForTestTransfer(ReadTest);
	WaitForTestTransfer(WriteTest);

	// Print benchmark detailed stats
	if (ReadTest)
		ShowDetailedStatus(ReadTest);
	else
		ShowDetailedStatus(WriteTest);

Done:
	if (Test.DeviceHandle)
	{
		usb_close(Test.DeviceHandle);
		Test.DeviceHandle = NULL;
	}
	FreeTransferParam(&ReadTest);
	FreeTransferParam(&WriteTest);

	DeleteCriticalSection(&DisplayCriticalSection);

	printf("Press any key to exit..");
	_getch();
	printf("\n");

	return 0;
}

const char BenchmarkHelpText[2993] =
{
    0x4C, 0x69, 0x62, 0x55, 0x73, 0x62, 0x2D, 0x57, 0x69, 0x6E, 0x33, 0x32, 0x20, 0x42, 0x65, 0x6E, 
    0x63, 0x68, 0x6D, 0x61, 0x72, 0x6B, 0x20, 0x43, 0x6F, 0x6E, 0x73, 0x6F, 0x6C, 0x65, 0x20, 0x41, 
    0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x0D, 0x0A, 0x0D, 0x0A, 0x55, 0x53, 
    0x41, 0x47, 0x45, 0x3A, 0x20, 0x62, 0x65, 0x6E, 0x63, 0x68, 0x6D, 0x61, 0x72, 0x6B, 0x20, 0x5B, 
    0x70, 0x69, 0x64, 0x3D, 0x5D, 0x20, 0x5B, 0x6C, 0x69, 0x73, 0x74, 0x5D, 0x20, 0x5B, 0x72, 0x65, 
    0x61, 0x64, 0x7C, 0x77, 0x72, 0x69, 0x74, 0x65, 0x7C, 0x6C, 0x6F, 0x6F, 0x70, 0x5D, 0x20, 0x5B, 
    0x6E, 0x6F, 0x74, 0x65, 0x73, 0x74, 0x73, 0x65, 0x6C, 0x65, 0x63, 0x74, 0x5D, 0x20, 0x5B, 0x76, 
    0x69, 0x64, 0x3D, 0x5D, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x72, 0x65, 0x74, 0x72, 0x79, 0x3D, 0x5D, 0x20, 
    0x5B, 0x74, 0x69, 0x6D, 0x65, 0x6F, 0x75, 0x74, 0x3D, 0x5D, 0x20, 0x5B, 0x62, 0x75, 0x66, 0x66, 
    0x65, 0x72, 0x73, 0x69, 0x7A, 0x65, 0x3D, 0x5D, 0x20, 0x5B, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 
    0x68, 0x3D, 0x5D, 0x20, 0x5B, 0x65, 0x70, 0x3D, 0x5D, 0x20, 0x5B, 0x69, 0x6E, 0x74, 0x66, 0x3D, 
    0x5D, 0x0D, 0x0A, 0x43, 0x6F, 0x6D, 0x6D, 0x61, 0x6E, 0x64, 0x73, 0x3A, 0x0D, 0x0A, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6C, 0x69, 0x73, 0x74, 0x20, 0x20, 0x3A, 0x20, 0x44, 
    0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x20, 0x61, 0x20, 0x6C, 0x69, 0x73, 0x74, 0x20, 0x6F, 0x66, 
    0x20, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 
    0x65, 0x73, 0x20, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x69, 
    0x6E, 0x67, 0x2E, 0x20, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x53, 0x65, 0x6C, 0x65, 0x63, 0x74, 0x20, 0x74, 0x68, 
    0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x75, 0x73, 0x65, 0x20, 
    0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x66, 0x72, 0x6F, 
    0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x69, 0x73, 0x74, 0x2E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x20, 0x3A, 0x20, 0x52, 0x65, 
    0x61, 0x64, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 
    0x63, 0x65, 0x2E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x77, 0x72, 
    0x69, 0x74, 0x65, 0x20, 0x3A, 0x20, 0x57, 0x72, 0x69, 0x74, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 
    0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x20, 0x3A, 0x20, 0x5B, 0x44, 0x65, 
    0x66, 0x61, 0x75, 0x6C, 0x74, 0x5D, 0x20, 0x52, 0x65, 0x61, 0x64, 0x20, 0x61, 0x6E, 0x64, 0x20, 
    0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 
    0x69, 0x63, 0x65, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 
    0x74, 0x69, 0x6D, 0x65, 0x2E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x6E, 0x6F, 0x74, 0x65, 0x73, 0x74, 0x73, 0x65, 0x6C, 0x65, 0x63, 0x74, 0x20, 0x3A, 0x20, 0x53, 
    0x6B, 0x69, 0x70, 0x73, 0x20, 0x73, 0x75, 0x62, 0x6D, 0x69, 0x74, 0x74, 0x69, 0x6E, 0x67, 0x20, 
    0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x72, 0x6F, 0x6C, 0x20, 0x74, 0x72, 0x61, 0x6E, 
    0x73, 0x66, 0x65, 0x72, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x67, 0x65, 0x74, 0x2F, 0x73, 0x65, 0x74, 
    0x20, 0x74, 0x68, 0x65, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x74, 0x65, 
    0x73, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2E, 0x20, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x6D, 
    0x61, 0x6B, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 
    0x74, 0x69, 0x6F, 0x6E, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x74, 0x69, 0x62, 0x6C, 0x65, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6E, 0x6F, 
    0x6E, 0x2D, 0x62, 0x65, 0x6E, 0x63, 0x68, 0x6D, 0x61, 0x72, 0x6B, 0x20, 0x66, 0x69, 0x72, 0x6D, 
    0x77, 0x61, 0x72, 0x65, 0x64, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x74, 0x68, 
    0x61, 0x74, 0x20, 0x68, 0x61, 0x76, 0x65, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x65, 0x6E, 0x64, 0x70, 0x6F, 0x69, 
    0x6E, 0x74, 0x28, 0x73, 0x29, 0x2E, 0x20, 0x20, 0x28, 0x66, 0x6F, 0x72, 0x63, 0x65, 0x73, 0x20, 
    0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x29, 0x0D, 0x0A, 0x53, 0x77, 0x69, 0x74, 
    0x63, 0x68, 0x65, 0x73, 0x3A, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x70, 0x69, 0x64, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3A, 0x20, 0x50, 0x72, 0x6F, 
    0x64, 0x75, 0x63, 0x74, 0x20, 0x69, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 
    0x65, 0x2E, 0x20, 0x28, 0x68, 0x65, 0x78, 0x29, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x76, 0x69, 0x64, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3A, 0x20, 
    0x56, 0x65, 0x6E, 0x64, 0x6F, 0x72, 0x20, 0x69, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x64, 0x65, 0x76, 
    0x69, 0x63, 0x65, 0x2E, 0x20, 0x28, 0x68, 0x65, 0x78, 0x29, 0x20, 0x28, 0x44, 0x65, 0x66, 0x61, 
    0x75, 0x6C, 0x74, 0x3D, 0x30, 0x78, 0x30, 0x34, 0x44, 0x38, 0x29, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x72, 0x79, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x3A, 0x20, 0x4E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x69, 0x6D, 
    0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x74, 0x72, 0x79, 0x20, 0x61, 0x20, 0x74, 0x72, 
    0x61, 0x6E, 0x73, 0x66, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x69, 0x6D, 0x65, 
    0x73, 0x6F, 0x75, 0x74, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x74, 
    0x69, 0x6D, 0x65, 0x6F, 0x75, 0x74, 0x20, 0x20, 0x20, 0x20, 0x3A, 0x20, 0x54, 0x72, 0x61, 0x6E, 
    0x73, 0x66, 0x65, 0x72, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x6F, 0x75, 0x74, 0x20, 0x76, 0x61, 0x6C, 
    0x75, 0x65, 0x2E, 0x20, 0x28, 0x69, 0x6E, 0x20, 0x6D, 0x69, 0x6C, 0x6C, 0x69, 0x73, 0x65, 0x63, 
    0x6F, 0x6E, 0x64, 0x73, 0x29, 0x20, 0x28, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x3D, 0x31, 
    0x29, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x54, 0x68, 0x65, 0x20, 0x74, 0x69, 0x6D, 
    0x65, 0x6F, 0x75, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 
    0x66, 0x6F, 0x72, 0x20, 0x72, 0x65, 0x61, 0x64, 0x2F, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x6F, 
    0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x66, 0x65, 0x72, 0x20, 
    0x74, 0x69, 0x6D, 0x65, 0x73, 0x20, 0x6F, 0x75, 0x74, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x74, 
    0x68, 0x61, 0x6E, 0x20, 0x7B, 0x72, 0x65, 0x74, 0x72, 0x79, 0x7D, 0x20, 0x74, 0x69, 0x6D, 0x65, 
    0x73, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x0D, 0x0A, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 
    0x65, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x73, 0x20, 0x61, 
    0x62, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x2E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x3A, 0x20, 0x54, 
    0x72, 0x61, 0x6E, 0x73, 0x66, 0x65, 0x72, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x73, 0x69, 0x7A, 
    0x65, 0x20, 0x69, 0x6E, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2E, 0x20, 0x28, 0x44, 0x65, 0x66, 
    0x61, 0x75, 0x6C, 0x74, 0x3D, 0x34, 0x30, 0x39, 0x36, 0x29, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x49, 0x6E, 0x63, 0x72, 0x65, 0x61, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x69, 
    0x73, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x67, 0x65, 0x6E, 
    0x65, 0x72, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x79, 0x69, 0x65, 0x6C, 0x64, 0x20, 0x68, 0x69, 0x67, 
    0x68, 0x65, 0x72, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x74, 0x72, 0x61, 0x6E, 0x73, 
    0x66, 0x65, 0x72, 0x20, 0x72, 0x61, 0x74, 0x65, 0x73, 0x2E, 0x20, 0x55, 0x73, 0x69, 0x6E, 0x67, 
    0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x67, 0x72, 0x65, 0x61, 0x74, 0x65, 0x72, 
    0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x36, 0x35, 0x35, 0x33, 0x36, 0x20, 0x69, 0x73, 0x20, 0x6E, 
    0x6F, 0x74, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x63, 0x6F, 0x6D, 0x6D, 
    0x65, 0x6E, 0x64, 0x65, 0x64, 0x2E, 0x20, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x70, 0x72, 0x69, 0x6F, 0x72, 0x69, 0x74, 0x79, 0x20, 0x20, 0x20, 0x3A, 0x20, 0x41, 
    0x62, 0x6F, 0x76, 0x65, 0x4E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x7C, 0x42, 0x65, 0x6C, 0x6F, 0x77, 
    0x4E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x7C, 0x48, 0x69, 0x67, 0x68, 0x65, 0x73, 0x74, 0x7C, 0x4C, 
    0x6F, 0x77, 0x65, 0x73, 0x74, 0x7C, 0x4E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x0D, 0x0A, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x28, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x3D, 0x41, 0x62, 0x6F, 
    0x76, 0x65, 0x4E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x29, 0x20, 0x54, 0x68, 0x65, 0x20, 0x74, 0x68, 
    0x72, 0x65, 0x61, 0x64, 0x20, 0x70, 0x72, 0x69, 0x6F, 0x72, 0x69, 0x74, 0x79, 0x20, 0x6C, 0x65, 
    0x76, 0x65, 0x6C, 0x20, 0x74, 0x6F, 0x20, 0x75, 0x73, 0x65, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x65, 0x73, 0x74, 0x2E, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 
    0x68, 0x20, 0x20, 0x20, 0x20, 0x3A, 0x20, 0x54, 0x68, 0x65, 0x20, 0x64, 0x69, 0x73, 0x70, 0x6C, 
    0x61, 0x79, 0x20, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 
    0x76, 0x61, 0x6C, 0x2E, 0x20, 0x28, 0x69, 0x6E, 0x20, 0x6D, 0x69, 0x6C, 0x6C, 0x69, 0x73, 0x65, 
    0x63, 0x6F, 0x6E, 0x64, 0x73, 0x29, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x28, 0x44, 
    0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x3D, 0x31, 0x30, 0x30, 0x30, 0x29, 0x20, 0x54, 0x68, 0x69, 
    0x73, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0x20, 0x74, 0x68, 
    0x65, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 
    0x2E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x64, 0x72, 0x69, 0x76, 
    0x65, 0x72, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3A, 0x20, 0x6C, 0x69, 0x62, 0x75, 0x73, 0x62, 0x31, 
    0x30, 0x7C, 0x77, 0x69, 0x6E, 0x75, 0x73, 0x62, 0x20, 0x28, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6C, 
    0x74, 0x3D, 0x77, 0x69, 0x6E, 0x75, 0x73, 0x62, 0x29, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x4C, 0x69, 0x62, 0x55, 0x73, 0x62, 0x2D, 0x57, 0x69, 0x6E, 0x33, 0x32, 0x20, 0x73, 0x75, 
    0x70, 0x70, 0x6F, 0x72, 0x74, 0x73, 0x20, 0x74, 0x68, 0x72, 0x65, 0x65, 0x20, 0x64, 0x69, 0x66, 
    0x66, 0x65, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x73, 0x20, 0x6F, 
    0x6E, 0x20, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x2E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x77, 0x69, 0x6E, 0x75, 0x73, 0x62, 0x2C, 0x20, 0x6C, 0x69, 0x62, 0x75, 0x73, 0x62, 
    0x2D, 0x77, 0x69, 0x6E, 0x33, 0x32, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6C, 0x69, 0x62, 0x75, 
    0x73, 0x62, 0x2D, 0x31, 0x2E, 0x30, 0x2E, 0x20, 0x20, 0x49, 0x66, 0x20, 0x77, 0x69, 0x6E, 0x75, 
    0x73, 0x62, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 
    0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x6C, 0x69, 0x62, 0x75, 0x73, 0x62, 0x2D, 0x77, 0x69, 0x6E, 
    0x33, 0x32, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 
    0x69, 0x62, 0x75, 0x73, 0x62, 0x2D, 0x77, 0x69, 0x6E, 0x33, 0x32, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 
    0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x2E, 0x20, 
    0x4F, 0x6E, 0x20, 0x75, 0x6E, 0x69, 0x78, 0x2D, 0x6C, 0x69, 0x6B, 0x65, 0x20, 0x70, 0x6C, 0x61, 
    0x74, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x20, 0x74, 0x68, 0x69, 0x73, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x20, 0x68, 0x61, 0x73, 0x20, 0x6E, 0x6F, 
    0x20, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0x2E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x65, 0x70, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3A, 0x20, 
    0x54, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x65, 0x6E, 0x64, 
    0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x75, 0x73, 0x65, 0x2E, 0x20, 0x46, 0x6F, 
    0x72, 0x20, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x65, 0x70, 0x3D, 0x30, 0x78, 0x30, 
    0x31, 0x2C, 0x20, 0x77, 0x6F, 0x75, 0x6C, 0x64, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x72, 0x65, 0x61, 0x64, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x30, 0x78, 0x38, 0x31, 0x20, 0x61, 
    0x6E, 0x64, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x30, 0x78, 0x30, 0x31, 
    0x2E, 0x20, 0x28, 0x68, 0x65, 0x78, 0x29, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x69, 0x6E, 0x74, 0x66, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3A, 0x20, 0x54, 
    0x68, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x20, 0x69, 0x64, 0x20, 
    0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x65, 0x6E, 0x64, 
    0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x72, 0x65, 0x73, 0x69, 0x64, 0x65, 0x73, 0x20, 0x69, 0x6E, 
    0x2E, 0x20, 0x20, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0D, 0x0A, 
    0x57, 0x41, 0x52, 0x4E, 0x49, 0x4E, 0x47, 0x3A, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 
    0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x77, 0x6F, 0x72, 0x6B, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 
    0x20, 0x63, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x20, 0x75, 0x73, 0x62, 0x20, 0x68, 0x61, 0x72, 0x64, 
    0x77, 0x61, 0x72, 0x65, 0x2E, 0x20, 0x55, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x69, 0x73, 
    0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x78, 0x61, 0x6D, 
    0x70, 0x6C, 0x65, 0x20, 0x6F, 0x6E, 0x20, 0x61, 0x20, 0x75, 0x73, 0x62, 0x20, 0x64, 0x65, 0x76, 
    0x69, 0x63, 0x65, 0x20, 0x69, 0x74, 0x20, 0x77, 0x61, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x64, 
    0x65, 0x73, 0x69, 0x67, 0x6E, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x63, 0x6F, 0x75, 0x6C, 
    0x64, 0x20, 0x62, 0x65, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x63, 0x61, 0x74, 0x61, 0x73, 0x74, 0x72, 0x6F, 0x70, 0x68, 0x69, 0x63, 0x21, 0x20, 0x54, 0x6F, 
    0x20, 0x6D, 0x65, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 
    0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2C, 0x20, 0x79, 0x6F, 0x75, 0x72, 0x20, 0x75, 0x73, 0x62, 
    0x20, 0x68, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 
    0x65, 0x6E, 0x74, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x75, 0x6E, 
    0x63, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x69, 0x74, 0x79, 0x20, 0x69, 0x6E, 0x20, 0x43, 0x6F, 
    0x6E, 0x66, 0x69, 0x67, 0x20, 0x31, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x49, 0x6E, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x20, 0x30, 0x2C, 0x20, 
    0x45, 0x6E, 0x64, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x73, 0x20, 0x30, 0x78, 0x30, 0x31, 0x20, 0x61, 
    0x6E, 0x64, 0x20, 0x30, 0x78, 0x38, 0x31, 0x2E, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x0D, 0x0A, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x73, 0x3A, 0x0D, 
    0x0A, 0x0D, 0x0A, 0x62, 0x65, 0x6E, 0x63, 0x68, 0x6D, 0x61, 0x72, 0x6B, 0x20, 0x76, 0x69, 0x64, 
    0x3D, 0x31, 0x32, 0x33, 0x34, 0x20, 0x70, 0x69, 0x64, 0x3D, 0x35, 0x36, 0x37, 0x38, 0x0D, 0x0A, 
    0x62, 0x65, 0x6E, 0x63, 0x68, 0x6D, 0x61, 0x72, 0x6B, 0x20, 0x76, 0x69, 0x64, 0x3D, 0x30, 0x78, 
    0x34, 0x44, 0x32, 0x20, 0x70, 0x69, 0x64, 0x3D, 0x30, 0x78, 0x31, 0x36, 0x32, 0x45, 0x0D, 0x0A, 
    0x62, 0x65, 0x6E, 0x63, 0x68, 0x6D, 0x61, 0x72, 0x6B, 0x20, 0x76, 0x69, 0x64, 0x3D, 0x30, 0x78, 
    0x34, 0x44, 0x32, 0x20, 0x70, 0x69, 0x64, 0x3D, 0x30, 0x78, 0x31, 0x36, 0x32, 0x45, 0x20, 0x62, 
    0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x69, 0x7A, 0x65, 0x3D, 0x36, 0x35, 0x35, 0x33, 0x36, 0x0D, 
0x0A, 
} ;

void ShowHelp(void)
{
	printf("%s", BenchmarkHelpText);
}